/*
 * Copyright 2005-2010 Erik Gilling
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

#include <stdio.h>
#include <getopt.h>
#include <string.h>

#include "pngread.h"

typedef struct {
	uint8_t w;
	uint16_t idx;
} __attribute__((packed)) gfx_glyph_info_t;

typedef struct {
	const uint8_t *data;
	const gfx_glyph_info_t *info;
	char minchar;
	char maxchar;
} gfx_font_t;

void usage( void );

int main( int argc, char *argv[] )
{
	unsigned long width, height;
	pixel_t *img_data;
	char *chars = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789({[<!@#$%^&*?_+-=;:,.\\\"/~>]})";
	int chars_idx, chars_len;
	pixel_t bg_color, fg_color, sep_color;
	int col;
	unsigned char minchar, maxchar;
	gfx_glyph_info_t info[256];
	int bytes,bits;
	int c;
	int i;
	char *name = NULL;
	char *fname = NULL;
	int option_index = 0;


	while( 1 ) {
		static struct option long_options[] = {
			{"help", 0, 0, 'h'},
			{"name", 1, 0, 'n'},
			{"chars", 1, 0, 'c'},
			{"file", 1, 0, 'f'},
			{0,0,0,0}
		};

		c = getopt_long( argc, argv, "hn:c:f:", long_options, &option_index );

		if( c == -1 ) {
			break;
		}

		switch( c ) {
		case 'h':
			usage();
			return 0;

		case 'n':
			name=optarg;
			break;

		case 'c':
			chars=optarg;
			break;

		case 'f':
			fname=optarg;
			break; 

		default:
			fprintf( stderr, "unkown option -%c %d\n", (char)c, c );
			usage();
			return 1;
		}
	}

	if( fname == NULL ) {
		printf( "no file name given\n" );
		usage();
		return 1;
	}

	if( name == NULL ) {
		printf( "no font name given\n" );
		usage();
		return 1;
	}

	if( pngread( fname, &width, &height,  &img_data ) < 0 ) {
		fprintf(stderr, "can't open %s", fname );
		return 1;
	}

	col = 0;
	bg_color = img_data[col++];
	fg_color = img_data[col++];
	sep_color = img_data[col++];

	printf( "/*\n" );
	printf( " * %s generated by png2font\n", name );
	printf( " */\n\n" );

	printf( "#include \"font.h\"\n\n");

	chars_len = strlen( chars );
	minchar = 0xff;
	maxchar = 0x00;
	memset( info, 0x0, sizeof( info ) );

	bytes = bits = 0;

	printf( "static uint8_t PROGMEM data[] = {\n" );

	for( chars_idx=0 ; chars_idx<chars_len ; chars_idx++ ) {
		c = chars[chars_idx];

		if( c > maxchar ) {
			maxchar = c;
		}
		if( c < minchar ) {
			minchar = c;
		}

		// find sep
		for( i=0 ; (col+i<width) && (!pixeleq(img_data[col+i],sep_color)) ; i++ ) 
		{ }

		info[c].w = i;
		info[c].idx = bytes;

		printf( "  /* '%c' */ ", c );

		int dx,dy,byte=0;
		for( dy=0 ; dy<height ; dy++ ) {
			for( dx=0 ; dx<i ; dx++ ) {
				byte >>=1;
				if( pixeleq( img_data[ dy*width + col+dx ], fg_color ) ) {
					byte |= 0x80;
				}

				bits++;
				if( bits == 8 ) {
					printf( " 0x%02x,", byte );
					byte=0;
					bits=0;
					bytes++;
				}
			}
		}

		while( bits != 0 ) {
			byte >>=1;
			bits++;
			if( bits == 8 ) {
				printf( " 0x%02x,", byte );
				byte=0;
				bits=0;
				bytes++;
			}
		}

		if( bits != 0 ) {
			printf( "'%c' does not fit evenly in a byte.  This case is not handled\n", c );
			return 1;
		}

		printf( "\n" );

		col += i+1;
		if( col >= width ) {
			col = width-1;
		}
	}

	printf( "};\n\n" );

	printf( "static struct font_glyph PROGMEM info[] = {\n" );
	for( c=minchar ; c<=maxchar ; c++ ) {
		printf( "  /* %c */ {%d, %d},\n", c,
			info[c].w, info[c].idx );
	}
	printf( "};\n\n" );

	printf( "struct font %s = {data, info, %lul, %d, %d};\n", name,
		height, minchar, maxchar );
	pngfree(img_data );

	return 0;
}

void usage( void )
{
	printf( "png2font -f <pngfilename> -n <fontname> -c \"<charsinpng>\"\n" );
}
